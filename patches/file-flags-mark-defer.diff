This diff moves the kernel-only FMARK and FDEFER flags from the fully
utilized and only 16-bit f_flag field to the grossly under-utilized
and 32-bit f_iflags field.

Index: sys/fcntl.h
===================================================================
RCS file: /home/mdempsky/anoncvs/cvs/src/sys/sys/fcntl.h,v
retrieving revision 1.11
diff -u -p -r1.11 fcntl.h
--- sys/fcntl.h	24 Nov 2007 12:59:28 -0000	1.11
+++ sys/fcntl.h	26 Jun 2011 06:07:15 -0000
@@ -92,8 +92,6 @@
 #define	O_TRUNC		0x0400		/* truncate to zero length */
 #define	O_EXCL		0x0800		/* error if already exists */
 #ifdef _KERNEL
-#define	FMARK		0x1000		/* mark during gc() */
-#define	FDEFER		0x2000		/* defer for next gc pass */
 #define	FHASLOCK	0x4000		/* descriptor holds advisory lock */
 #endif
 
Index: sys/file.h
===================================================================
RCS file: /home/mdempsky/anoncvs/cvs/src/sys/sys/file.h,v
retrieving revision 1.27
diff -u -p -r1.27 file.h
--- sys/file.h	19 Jul 2010 23:00:15 -0000	1.27
+++ sys/file.h	26 Jun 2011 06:07:46 -0000
@@ -88,6 +88,8 @@ struct file {
 
 #define FIF_WANTCLOSE		0x01	/* a close is waiting for usecount */
 #define FIF_LARVAL		0x02	/* not fully constructed, don't use */
+#define FIF_MARK		0x04	/* mark during gc() */
+#define FIF_DEFER		0x08	/* defer for next gc pass */
 
 #define FILE_IS_USABLE(fp) \
 	(((fp)->f_iflags & (FIF_WANTCLOSE|FIF_LARVAL)) == 0)
Index: kern/uipc_usrreq.c
===================================================================
RCS file: /home/mdempsky/anoncvs/cvs/src/sys/kern/uipc_usrreq.c,v
retrieving revision 1.51
diff -u -p -r1.51 uipc_usrreq.c
--- kern/uipc_usrreq.c	17 May 2011 00:17:01 -0000	1.51
+++ kern/uipc_usrreq.c	26 Jun 2011 06:06:51 -0000
@@ -818,21 +818,21 @@ unp_gc(void)
 	unp_gcing = 1;
 	unp_defer = 0;
 	LIST_FOREACH(fp, &filehead, f_list)
-		fp->f_flag &= ~(FMARK|FDEFER);
+		fp->f_iflags &= ~(FIF_MARK|FIF_DEFER);
 	do {
 		LIST_FOREACH(fp, &filehead, f_list) {
-			if (fp->f_flag & FDEFER) {
-				fp->f_flag &= ~FDEFER;
+			if (fp->f_iflags & FIF_DEFER) {
+				fp->f_iflags &= ~FIF_DEFER;
 				unp_defer--;
 			} else {
 				if (fp->f_count == 0)
 					continue;
-				if (fp->f_flag & FMARK)
+				if (fp->f_iflags & FIF_MARK)
 					continue;
 				if (fp->f_count == fp->f_msgcount)
 					continue;
 			}
-			fp->f_flag |= FMARK;
+			fp->f_iflags |= FIF_MARK;
 
 			if (fp->f_type != DTYPE_SOCKET ||
 			    (so = (struct socket *)fp->f_data) == NULL)
@@ -904,7 +904,7 @@ unp_gc(void)
 		nextfp = LIST_NEXT(fp, f_list);
 		if (fp->f_count == 0)
 			continue;
-		if (fp->f_count == fp->f_msgcount && !(fp->f_flag & FMARK)) {
+		if (fp->f_count == fp->f_msgcount && !(fp->f_iflags & FIF_MARK)) {
 			*fpp++ = fp;
 			nunref++;
 			FREF(fp);
@@ -968,17 +968,17 @@ unp_mark(struct file *fp)
 	if (fp == NULL)
 		return;
 
-	if (fp->f_flag & FMARK)
+	if (fp->f_iflags & FIF_MARK)
 		return;
 
-	if (fp->f_flag & FDEFER)
+	if (fp->f_iflags & FIF_DEFER)
 		return;
 
 	if (fp->f_type == DTYPE_SOCKET) {
 		unp_defer++;
-		fp->f_flag |= FDEFER;
+		fp->f_iflags |= FIF_DEFER;
 	} else {
-		fp->f_flag |= FMARK;
+		fp->f_iflags |= FIF_MARK;
 	}
 }
 
